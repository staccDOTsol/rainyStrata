import{jsx as e}from"react/jsx-runtime";import{Transaction as r,SYSVAR_CLOCK_PUBKEY as s}from"@solana/web3.js";import{useAccelerator as t,useEndpoint as a,useCollectionOwnedAmount as i}from"@strata-foundation/react";import{sendAndConfirmWithRetry as n}from"@strata-foundation/spl-utils";import{createContext as o,useContext as c}from"react";import{useAsyncCallback as d}from"react-async-hook";import{useChatSdk as m}from"./chatSdk.js";import{useChat as l}from"../hooks/useChat.js";import{useDelegateWallet as p}from"../hooks/useDelegateWallet.js";import{useChatPermissionsFromChat as u}from"../hooks/useChatPermissionsFromChat.js";async function y({chatKey:e,chatSdk:t,accelerator:a,delegateWalletKeypair:i,cluster:o,onAddPendingMessage:c,message:d,nftMint:m,readPermissionAmount:l,readPermissionKey:p,readPermissionType:u}){if(t&&e){const y=i?.publicKey||t.wallet.publicKey,{instructions:g,signers:h,output:{messageId:f}}=await t.sendMessageInstructions({readPermissionAmount:l,readPermissionKey:p,readPermissionType:u,nftMint:m,delegateWalletKeypair:i,payer:y,chat:e,message:d,encrypted:"localnet"!==o}),P=await Promise.all(g.map((async(e,s)=>{const n=new r;n.recentBlockhash=(await t.provider.connection.getLatestBlockhash()).blockhash,n.feePayer=y,n.add(...e),h[s].length>0&&n.sign(...h[s]),i||await t.provider.wallet.signTransaction(n);const c=n.serialize();a?.sendTransaction(o,n);return{txid:await t.provider.connection.sendRawTransaction(c,{skipPreflight:!0}),rawTx:c}}))),w=Number((await t.provider.connection.getAccountInfo(s,"processed")).data.readBigInt64LE(32));if(c){const{fileAttachments:r,...s}=d,a={...s,decryptedAttachments:r};c({complete:!0,type:a.type,sender:t.wallet.publicKey,id:f,content:JSON.stringify(a),txids:P.map((({txid:e})=>e)),chatKey:e,getDecodedMessage:()=>Promise.resolve(a),encryptedSymmetricKey:"",readPermissionKey:p,readPermissionAmount:l,readPermissionType:u,startBlockTime:w,endBlockTime:w,parts:[],pending:!0,referenceMessageId:a.referenceMessageId||null})}await Promise.all(P.map((({rawTx:e})=>n(t.provider.connection,e,{skipPreflight:!0},"confirmed"))))}}function g({chatKey:e}){const{chatSdk:r}=m(),{accelerator:s}=t(),{keypair:n}=p();l(e);const{cluster:o}=a(),{info:c}=u(e),{matches:g}=i(c?.postPermissionKey),{error:h,loading:f,execute:P}=d(y);return{error:h,sendMessage:({message:t,onAddPendingMessage:a,readPermissionKey:i=c?.readPermissionKey,readPermissionAmount:d=c?.defaultReadPermissionAmount,readPermissionType:m=c?.readPermissionType})=>P({chatKey:e,chatSdk:r,accelerator:s,delegateWalletKeypair:n,cluster:o,message:t,onAddPendingMessage:a,nftMint:g&&g[0],readPermissionType:m,readPermissionKey:i,readPermissionAmount:d}),loading:f}}const h=o({}),f=({children:r,...s})=>{const t=g(s);return e(h.Provider,Object.assign({value:t},{children:r}),void 0)},P=()=>{const e=c(h);if(void 0===e)throw new Error("useSendMessage must be used within a ReplyProvider");return e};export{h as SendMessageContext,f as SendMessageProvider,P as useSendMessage,g as useStrataSendMessage};
//# sourceMappingURL=sendMessage.js.map
